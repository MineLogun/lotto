// lotto.c - 6/45 로또 시스템 (생성, 추첨, 검증)
// 빌드: gcc -O2 -std=c11 lotto.c -o lotto
// 실행: ./lotto
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define MAX_TICKETS 1000
#define N_NUMS 6
#define MAX_NUM 45

typedef struct {
    int nums[N_NUMS];   // 정렬된 번호 6개
    int matches;        // 당첨번호 일치 개수
    int bonusMatch;     // 보너스 일치 여부 (0/1)
    int rank;           // 등수(1~5, 아니면 0)
} Ticket;

typedef struct {
    int win[N_NUMS]; // 당첨번호 6개(정렬)
    int bonus;       // 보너스
    int drawn;       // 1이면 추첨완료
} Draw;

// 유틸: 오름차순 정렬 (삽입정렬)
static void sort6(int a[N_NUMS]) {
    for (int i = 1; i < N_NUMS; ++i) {
        int key = a[i], j = i - 1;
        while (j >= 0 && a[j] > key) { a[j+1] = a[j]; j--; }
        a[j+1] = key;
    }
}

// 유틸: 배열에 값이 있는지
static int contains(const int *arr, int len, int v) {
    for (int i = 0; i < len; ++i) if (arr[i] == v) return 1;
    return 0;
}

// 유틸: 1..MAX_NUM에서 중복 없이 n개 뽑아 정렬
static void pick_unique_sorted(int *out, int n) {
    int picked = 0;
    while (picked < n) {
        int x = (rand() % MAX_NUM) + 1; // 1..45
        if (!contains(out, picked, x)) out[picked++] = x;
    }
    // 정렬
    for (int i = 1; i < n; ++i) {
        int key = out[i], j = i - 1;
        while (j >= 0 && out[j] > key) { out[j+1] = out[j]; j--; }
        out[j+1] = key;
    }
}

// 티켓 생성
static Ticket make_ticket(void) {
    Ticket t = {0};
    pick_unique_sorted(t.nums, N_NUMS);
    t.matches = 0; t.bonusMatch = 0; t.rank = 0;
    return t;
}

// 추첨 (당첨번호 6 + 보너스 1)
static Draw draw_numbers(void) {
    Draw d = {0};
    pick_unique_sorted(d.win, N_NUMS);

    // 보너스는 남은 번호 중에서 선택
    int bonus;
    do { bonus = (rand() % MAX_NUM) + 1; }
    while (contains(d.win, N_NUMS, bonus));
    d.bonus = bonus;
    d.drawn = 1;
    return d;
}

// 등수 판정 규칙 (대한민국 로또)
// 1등: 6개 일치
// 2등: 5개 + 보너스
// 3등: 5개
// 4등: 4개
// 5등: 3개
static int judge_rank(int matches, int bonusMatch) {
    if (matches == 6) return 1;
    if (matches == 5 && bonusMatch) return 2;
    if (matches == 5) return 3;
    if (matches == 4) return 4;
    if (matches == 3) return 5;
    return 0;
}

// 티켓 채점
static void score_ticket(Ticket *t, const Draw *d) {
    int m = 0;
    for (int i = 0; i < N_NUMS; ++i) if (contains(d->win, N_NUMS, t->nums[i])) m++;
    int b = contains(t->nums, N_NUMS, d->bonus) ? 1 : 0;
    t->matches = m;
    t->bonusMatch = b;
    t->rank = judge_rank(m, b);
}

// 출력 헬퍼
static void print_nums(const int *a, int n) {
    for (int i = 0; i < n; ++i) {
        printf("%2d%s", a[i], (i == n-1 ? "" : " "));
    }
}

static void print_ticket(const Ticket *t, int idx) {
    printf("티켓 #%d: [ ", idx);
    print_nums(t->nums, N_NUMS);
    printf(" ]");
    if (t->rank) {
        printf("  -> %d개 일치%s, 등수: %d등\n",
               t->matches, t->bonusMatch ? " + 보너스" : "", t->rank);
    } else {
        printf("\n");
    }
}

static void print_draw(const Draw *d) {
    printf("당첨번호: [ ");
    print_nums(d->win, N_NUMS);
    printf(" ]  보너스: %d\n", d->bonus);
}

int main(void) {
    // 난수 시드
    srand((unsigned int)time(NULL));

    Ticket tickets[MAX_TICKETS];
    int ticketCount = 0;
    Draw draw = {0};

    while (1) {
        printf("\n===== 6/45 로또 시스템 =====\n");
        printf("1) 티켓 생성\n");
        printf("2) 현재 티켓 목록 보기\n");
        printf("3) 추첨(당첨번호 뽑기)\n");
        printf("4) 당첨번호 보기\n");
        printf("5) 채점(등수 확인)\n");
        printf("6) 초기화(티켓/추첨 리셋)\n");
        printf("0) 종료\n");
        printf("선택: ");

        int cmd;
        if (scanf("%d", &cmd) != 1) { // 입력 오류 처리
            int c; while ((c = getchar()) != '\n' && c != EOF) {}
            continue;
        }

        if (cmd == 0) {
            printf("종료합니다.\n");
            break;
        } else if (cmd == 1) {
            int n;
            printf("생성할 티켓 수(1~%d): ", MAX_TICKETS - ticketCount);
            if (scanf("%d", &n) != 1 || n < 1 || ticketCount + n > MAX_TICKETS) {
                printf("입력 범위를 확인하세요.\n");
                continue;
            }
            for (int i = 0; i < n; ++i) {
                tickets[ticketCount++] = make_ticket();
            }
            printf("%d장 생성 완료. 총 %d장 보유.\n", n, ticketCount);
        } else if (cmd == 2) {
            if (ticketCount == 0) {
                printf("티켓이 없습니다.\n");
            } else {
                for (int i = 0; i < ticketCount; ++i) {
                    print_ticket(&tickets[i], i+1);
                }
            }
        } else if (cmd == 3) {
            draw = draw_numbers();
            printf("추첨 완료!\n");
            print_draw(&draw);
        } else if (cmd == 4) {
            if (!draw.drawn) printf("아직 추첨하지 않았습니다.\n");
            else print_draw(&draw);
        } else if (cmd == 5) {
            if (!draw.drawn) {
                printf("먼저 추첨(3번)을 실행하세요.\n");
                continue;
            }
            if (ticketCount == 0) {
                printf("채점할 티켓이 없습니다.\n");
                continue;
            }
            int ranks[6] = {0}; // 인덱스 = 등수(0~5)
            for (int i = 0; i < ticketCount; ++i) {
                score_ticket(&tickets[i], &draw);
                if (tickets[i].rank >= 1 && tickets[i].rank <= 5) {
                    ranks[tickets[i].rank]++;
                } else {
                    ranks[0]++; // 꽝
                }
            }
            printf("=== 채점 결과 ===\n");
            print_draw(&draw);
            for (int i = 0; i < ticketCount; ++i) {
                print_ticket(&tickets[i], i+1);
            }
            printf("\n요약: 1등:%d  2등:%d  3등:%d  4등:%d  5등:%d  꽝:%d\n",
                   ranks[1], ranks[2], ranks[3], ranks[4], ranks[5], ranks[0]);
        } else if (cmd == 6) {
            ticketCount = 0;
            memset(tickets, 0, sizeof(tickets));
            memset(&draw, 0, sizeof(draw));
            printf("초기화 완료.\n");
        } else {
            printf("메뉴 번호를 다시 선택하세요.\n");
        }
    }
    return 0;
}